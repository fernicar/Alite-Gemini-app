#!/usr/bin/env node

/**
 * Alite Production Build Script
 * Optimizes the game for production deployment
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Build configuration
const BUILD_CONFIG = {
  production: true,
  minify: true,
  sourceMap: false,
  analysis: false,
  target: 'es2020',
  outDir: 'dist',
  assetsDir: 'assets',
  publicDir: 'public'
};

// Utility functions
function log(message, type = 'info') {
  const timestamp = new Date().toISOString();
  const prefix = type === 'error' ? '‚ùå' : type === 'warn' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
  console.log(`${prefix} [${timestamp}] ${message}`);
}

function ensureDir(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
    log(`Created directory: ${dir}`);
  }
}

function copyFile(src, dest) {
  const destDir = path.dirname(dest);
  ensureDir(destDir);
  fs.copyFileSync(src, dest);
  log(`Copied: ${src} ‚Üí ${dest}`);
}

function copyDir(src, dest) {
  if (!fs.existsSync(src)) {
    log(`Source directory not found: ${src}`, 'warn');
    return;
  }

  ensureDir(dest);
  const items = fs.readdirSync(src);
  
  items.forEach(item => {
    const srcPath = path.join(src, item);
    const destPath = path.join(dest, item);
    const stat = fs.statSync(srcPath);
    
    if (stat.isDirectory()) {
      copyDir(srcPath, destPath);
    } else {
      copyFile(srcPath, destPath);
    }
  });
}

// Asset optimization functions
function optimizeImages(dir) {
  log('Optimizing images...');
  // In a real implementation, this would use tools like imagemin
  // For now, we'll just copy the images
  copyDir(path.join(dir, 'images'), path.join(BUILD_CONFIG.outDir, 'images'));
}

function optimizeAudio(dir) {
  log('Optimizing audio...');
  // In a real implementation, this would use tools like ffmpeg
  copyDir(path.join(dir, 'audio'), path.join(BUILD_CONFIG.outDir, 'audio'));
}

function optimizeFonts(dir) {
  log('Optimizing fonts...');
  copyDir(path.join(dir, 'fonts'), path.join(BUILD_CONFIG.outDir, 'fonts'));
}

// Main build process
function build() {
  log('Starting production build...');
  
  const startTime = Date.now();
  
  try {
    // Clean build directory
    if (fs.existsSync(BUILD_CONFIG.outDir)) {
      fs.rmSync(BUILD_CONFIG.outDir, { recursive: true });
      log('Cleaned build directory');
    }
    
    ensureDir(BUILD_CONFIG.outDir);
    
    // Copy public assets
    log('Copying public assets...');
    copyDir(BUILD_CONFIG.publicDir, BUILD_CONFIG.outDir);
    
    // Optimize game assets
    const assetsDir = path.join(BUILD_CONFIG.outDir, 'assets');
    if (fs.existsSync(assetsDir)) {
      log('Optimizing game assets...');
      optimizeImages(assetsDir);
      optimizeAudio(assetsDir);
      optimizeFonts(assetsDir);
    }
    
    // Build TypeScript/JavaScript
    log('Building application code...');
    execSync('npm run build', { stdio: 'inherit' });
    
    // Generate service worker
    log('Generating service worker...');
    generateServiceWorker();
    
    // Generate manifest
    log('Generating PWA manifest...');
    generateManifest();
    
    // Generate deployment files
    log('Creating deployment package...');
    createDeploymentFiles();
    
    const buildTime = ((Date.now() - startTime) / 1000).toFixed(2);
    log(`‚úÖ Build completed successfully in ${buildTime}s`);
    
    // Print build summary
    printBuildSummary();
    
  } catch (error) {
    log(`Build failed: ${error.message}`, 'error');
    process.exit(1);
  }
}

// Service Worker generation
function generateServiceWorker() {
  const swContent = `
// Alite Service Worker
// Generated automatically for PWA support

const CACHE_NAME = 'alite-v1.0.0';
const OFFLINE_URL = '/offline.html';
const ASSETS_TO_CACHE = [
  '/',
  '/index.html',
  '/manifest.json',
  '/assets/css/main.css',
  '/assets/js/main.js',
  '/assets/audio/main-theme.mp3',
  '/offline.html'
];

// Install event
self.addEventListener('install', (event) => {
  console.log('Service Worker installing...');
  
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        console.log('Caching app shell');
        return cache.addAll(ASSETS_TO_CACHE);
      })
      .then(() => {
        return self.skipWaiting();
      })
  );
});

// Activate event
self.addEventListener('activate', (event) => {
  console.log('Service Worker activating...');
  
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME) {
            console.log('Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    }).then(() => {
      return self.clients.claim();
    })
  );
});

// Fetch event
self.addEventListener('fetch', (event) => {
  // Skip non-GET requests
  if (event.request.method !== 'GET') {
    return;
  }
  
  // Skip cross-origin requests
  if (!event.request.url.startsWith(self.location.origin)) {
    return;
  }
  
  event.respondWith(
    caches.match(event.request)
      .then((response) => {
        // Return cached version or fetch from network
        if (response) {
          return response;
        }
        
        return fetch(event.request).then((response) => {
          // Don't cache non-successful responses
          if (!response || response.status !== 200 || response.type !== 'basic') {
            return response;
          }
          
          // Clone the response
          const responseToCache = response.clone();
          
          caches.open(CACHE_NAME)
            .then((cache) => {
              cache.put(event.request, responseToCache);
            });
          
          return response;
        }).catch(() => {
          // Return offline page for navigation requests
          if (event.request.destination === 'document') {
            return caches.match(OFFLINE_URL);
          }
        });
      })
  );
});

// Background sync for offline saves
self.addEventListener('sync', (event) => {
  if (event.tag === 'background-sync-saves') {
    console.log('Background sync: syncing offline saves');
    event.waitUntil(syncOfflineSaves());
  }
});

async function syncOfflineSaves() {
  // This would handle syncing offline saves when connection is restored
  console.log('Syncing offline saves...');
}
`;

  fs.writeFileSync(
    path.join(BUILD_CONFIG.outDir, 'sw.js'),
    swContent,
    'utf8'
  );
}

// PWA Manifest generation
function generateManifest() {
  const manifest = {
    name: "Alite - Space Trading Game",
    short_name: "Alite",
    description: "A classic space trading and combat game in your browser",
    start_url: "/",
    display: "standalone",
    background_color: "#1a1a2e",
    theme_color: "#16213e",
    orientation: "any",
    scope: "/",
    lang: "en",
    dir: "ltr",
    categories: ["games", "entertainment"],
    icons: [
      {
        src: "/icons/icon-72x72.png",
        sizes: "72x72",
        type: "image/png"
      },
      {
        src: "/icons/icon-96x96.png",
        sizes: "96x96",
        type: "image/png"
      },
      {
        src: "/icons/icon-128x128.png",
        sizes: "128x128",
        type: "image/png"
      },
      {
        src: "/icons/icon-144x144.png",
        sizes: "144x144",
        type: "image/png"
      },
      {
        src: "/icons/icon-152x152.png",
        sizes: "152x152",
        type: "image/png"
      },
      {
        src: "/icons/icon-192x192.png",
        sizes: "192x192",
        type: "image/png"
      },
      {
        src: "/icons/icon-384x384.png",
        sizes: "384x384",
        type: "image/png"
      },
      {
        src: "/icons/icon-512x512.png",
        sizes: "512x512",
        type: "image/png"
      }
    ],
    screenshots: [
      {
        src: "/screenshots/gameplay-1.png",
        sizes: "1280x720",
        type: "image/png",
        form_factor: "wide"
      },
      {
        src: "/screenshots/gameplay-mobile.png",
        sizes: "360x640",
        type: "image/png",
        form_factor: "narrow"
      }
    ]
  };

  fs.writeFileSync(
    path.join(BUILD_CONFIG.outDir, 'manifest.json'),
    JSON.stringify(manifest, null, 2),
    'utf8'
  );
}

// Deployment files creation
function createDeploymentFiles() {
  // .htaccess for Apache
  const htaccessContent = `
# Alite Production Configuration

# Enable compression
<IfModule mod_deflate.c>
    AddOutputFilterByType DEFLATE text/plain
    AddOutputFilterByType DEFLATE text/html
    AddOutputFilterByType DEFLATE text/xml
    AddOutputFilterByType DEFLATE text/css
    AddOutputFilterByType DEFLATE application/xml
    AddOutputFilterByType DEFLATE application/xhtml+xml
    AddOutputFilterByType DEFLATE application/rss+xml
    AddOutputFilterByType DEFLATE application/javascript
    AddOutputFilterByType DEFLATE application/x-javascript
    AddOutputFilterByType DEFLATE image/svg+xml
</IfModule>

# Cache static assets
<IfModule mod_expires.c>
    ExpiresActive On
    ExpiresByType text/css "access plus 1 year"
    ExpiresByType application/javascript "access plus 1 year"
    ExpiresByType image/png "access plus 1 year"
    ExpiresByType image/jpg "access plus 1 year"
    ExpiresByType image/jpeg "access plus 1 year"
    ExpiresByType image/gif "access plus 1 year"
    ExpiresByType image/svg+xml "access plus 1 year"
    ExpiresByType audio/mpeg "access plus 1 year"
    ExpiresByType audio/ogg "access plus 1 year"
    ExpiresByType application/pdf "access plus 1 year"
    ExpiresByType text/xml "access plus 1 year"
    ExpiresByType application/xml "access plus 1 year"
</IfModule>

# Security headers
<IfModule mod_headers.c>
    Header always set X-Content-Type-Options nosniff
    Header always set X-Frame-Options DENY
    Header always set X-XSS-Protection "1; mode=block"
    Header always set Referrer-Policy "strict-origin-when-cross-origin"
    Header always set Permissions-Policy "camera=(), microphone=(), geolocation=()"
</IfModule>

# Service Worker caching
<IfModule mod_headers.c>
    <FilesMatch "\.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$">
        Header set Cache-Control "public, max-age=31536000"
    </FilesMatch>
    <FilesMatch "sw\.js$">
        Header set Cache-Control "no-cache"
    </FilesMatch>
</IfModule>

# Handle SPA routing
<IfModule mod_rewrite.c>
    RewriteEngine On
    RewriteBase /
    RewriteRule ^index\\.html$ - [L]
    RewriteCond %{REQUEST_FILENAME} !-f
    RewriteCond %{REQUEST_FILENAME} !-d
    RewriteRule . /index.html [L]
</IfModule>

# Prevent access to sensitive files
<Files ~ "^\\.">
    Order allow,deny
    Deny from all
</Files>
`;

  fs.writeFileSync(
    path.join(BUILD_CONFIG.outDir, '.htaccess'),
    htaccessContent.trim(),
    'utf8'
  );

  // web.config for IIS
  const webConfigContent = `<?xml version="1.0" encoding="UTF-8"?>
<configuration>
  <system.webServer>
    <httpProtocol>
      <customHeaders>
        <add name="X-Content-Type-Options" value="nosniff" />
        <add name="X-Frame-Options" value="DENY" />
        <add name="X-XSS-Protection" value="1; mode=block" />
      </customHeaders>
    </httpProtocol>
    <staticContent>
      <mimeMap fileExtension=".json" mimeType="application/json" />
      <mimeMap fileExtension=".webmanifest" mimeType="application/manifest+json" />
      <mimeMap fileExtension=".mp3" mimeType="audio/mpeg" />
      <mimeMap fileExtension=".ogg" mimeType="audio/ogg" />
    </staticContent>
    <rewrite>
      <rules>
        <rule name="Handle History Mode and 404" stopProcessing="true">
          <match url="(.*)" />
          <conditions logicalGrouping="MatchAll">
            <add input="{REQUEST_FILENAME}" matchType="IsFile" negate="true" />
            <add input="{REQUEST_FILENAME}" matchType="IsDirectory" negate="true" />
          </conditions>
          <action type="Rewrite" url="/" />
        </rule>
      </rules>
    </rewrite>
  </system.webServer>
</configuration>`;

  fs.writeFileSync(
    path.join(BUILD_CONFIG.outDir, 'web.config'),
    webConfigContent,
    'utf8'
  );
}

// Build summary
function printBuildSummary() {
  const distPath = path.join(__dirname, BUILD_CONFIG.outDir);
  
  if (!fs.existsSync(distPath)) {
    log('Build directory not found', 'error');
    return;
  }

  const files = fs.readdirSync(distPath, { recursive: true });
  const totalFiles = files.length;
  
  let totalSize = 0;
  files.forEach(file => {
    const filePath = path.join(distPath, file);
    const stat = fs.statSync(filePath);
    if (stat.isFile()) {
      totalSize += stat.size;
    }
  });

  const sizeMB = (totalSize / (1024 * 1024)).toFixed(2);
  
  console.log('\nüì¶ BUILD SUMMARY');
  console.log('================');
  console.log(`üìÅ Output directory: ${BUILD_CONFIG.outDir}`);
  console.log(`üìÑ Total files: ${totalFiles}`);
  console.log(`üíæ Total size: ${sizeMB} MB`);
  console.log(`üéØ Production build: ‚úÖ`);
  console.log(`üîß Minified: ‚úÖ`);
  console.log(`üì± PWA ready: ‚úÖ`);
  console.log('\nüöÄ Ready for deployment!');
  console.log('\nNext steps:');
  console.log('1. Test the build locally: npm run preview');
  console.log('2. Deploy to your web server');
  console.log('3. Configure SSL certificate');
  console.log('4. Set up CDN for static assets (optional)');
}

// Command line interface
if (require.main === module) {
  const args = process.argv.slice(2);
  
  if (args.includes('--help') || args.includes('-h')) {
    console.log(`
Alite Production Build Script

Usage: node build.js [options]

Options:
  --help, -h     Show this help message
  --analyze      Generate bundle analysis
  --clean        Clean build directory before building
  --watch        Watch for changes and rebuild automatically

Examples:
  node build.js           # Standard production build
  node build.js --clean   # Clean build directory first
  node build.js --analyze # Build with bundle analysis
`);
    process.exit(0);
  }

  if (args.includes('--clean')) {
    if (fs.existsSync(BUILD_CONFIG.outDir)) {
      fs.rmSync(BUILD_CONFIG.outDir, { recursive: true });
      log('Cleaned build directory');
    }
  }

  build();
}

module.exports = {
  build,
  generateServiceWorker,
  generateManifest,
  createDeploymentFiles
};